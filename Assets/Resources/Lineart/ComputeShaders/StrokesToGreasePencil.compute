#pragma kernel SetStrokeLengthAtTail
#pragma kernel CalculateArrayOffsets
#pragma kernel MoveToDenseArray
#pragma kernel InvalidateEntries

#include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl"
#include "silhouette_defines.hh"
#include "Assets/Resources/GreasePencil/gpencil_info.hh"
#include "Assets/Resources/GreasePencil/gpencil_defines.hh"

RWStructuredBuffer<StrokeData> _strokes;

//Todo: rename to domain size(this num verts in sharp edge case)
uint _NumFaces;

RWStructuredBuffer<uint> numStrokesCounter;
RWStructuredBuffer<uint> numStrokePointsCounter;


RWStructuredBuffer<GreasePencilStrokeVert> _denseArray;
RWStructuredBuffer<GreasePencilColorVert> _colorArray;

[numthreads(128,1,1)]
void SetStrokeLengthAtTail(uint3 id : SV_DispatchThreadID)
{
    uint idx = id.x;
    if (idx >= _NumFaces) return;
    StrokeData s = _strokes[idx];
    if (IsInvalid(s)) return;
    if (!IsChild(s))
    {
        _strokes[s.minPoint].totalStrokeLength = s.rank +1;
    }
}

[numthreads(128,1,1)]
void CalculateArrayOffsets(uint3 id : SV_DispatchThreadID)
{
    uint i = id.x;
    if (i >= _NumFaces) return;
    StrokeData s = _strokes[i];
    if (IsInvalid(s)) return;
    
    
    uint strokeBufferLength = _strokes[s.minPoint].totalStrokeLength + (IsCyclic(s)?1:0) + 2;
    
    if (_strokes[i].minPoint == i)
    {
        InterlockedAdd(numStrokePointsCounter[0], strokeBufferLength, _strokes[i].strokePointsOffset);
        // InterlockedAdd(numStrokesCounter[0], 1u, _strokes[i].strokeIdx);
    }
}

[numthreads(128,1,1)]
void InvalidateEntries(uint3 id : SV_DispatchThreadID)
{
    uint i = id.x;
    _denseArray[i].mat = -1;
    _denseArray[i].uv_fill = float2(-1,-1);
}
    

uint unit_float_to_uchar_clamp(float val)
{
    return (uint)round(saturate(val) * 255.0);
}

uint pack_rotation_aspect_hardness_miter(
    const float rot,
    const float asp,
    const float softness,
    const float miter_angle)
{
    uint packed = 0;
    /* Aspect uses 9 bits */
    float asp_normalized = (asp > 1.0f) ? (1.0f / asp) : asp;
    /* Use the default aspect ratio of 1 when the value is outside of the valid range. */
    if (asp_normalized <= 0.0f) {
        asp_normalized = 1.0f;
    }
    packed |= uint(unit_float_to_uchar_clamp(asp_normalized));
    /* Store if inverted in the 9th bit. */
    if (asp > 1.0f) {
        packed |= 1 << 8;
    }
    /* Rotation uses 9 bits */
    /* Rotation are in [-90..90] degree range, so we can encode the sign of the angle + the cosine
     * because the cosine will always be positive. */
    packed |= unit_float_to_uchar_clamp(cos(rot)) << 9;
    /* Store sine sign in 9th bit. */
    if (rot < 0.0f) {
        packed |= 1 << 17;
    }
    /* Hardness uses 8 bits */
    packed |= unit_float_to_uchar_clamp(1.0f - softness) << 18;
    

    /* Miter Angle uses the last 6 bits */
    if (miter_angle <= GP_STROKE_MITER_ANGLE_ROUND) {
        packed |= GP_CORNER_TYPE_ROUND_BITS << 26;
    }
    else if (miter_angle >= GP_STROKE_MITER_ANGLE_BEVEL) {
        packed |= GP_CORNER_TYPE_BEVEL_BITS << 26;
    }
    else {
        const float miter_norm = (miter_angle / PI);
        packed |= clamp(int(miter_norm * GP_CORNER_TYPE_MITER_NUMBER), 1, GP_CORNER_TYPE_MITER_NUMBER) << 26;
    }

    return packed;
}

float _radiusMultiplier = 1.0f;

[numthreads(128,1,1)]
void MoveToDenseArray(uint3 id : SV_DispatchThreadID)
{
    uint i = id.x;
    if (i >= _NumFaces) return;
    StrokeData s = _strokes[i];
    if (IsInvalid(s)) return;
    StrokeData tail = _strokes[s.minPoint]; 
    int offsetInStroke = s.rank+1;
    uint globalOffset = tail.strokePointsOffset + offsetInStroke;
    
    
    GreasePencilStrokeVert gpVert;
    gpVert.pos = s.pos;
    gpVert.radius = _radiusMultiplier;
    
    gpVert.mat = 0;
    gpVert.stroke_id = tail.strokePointsOffset;
    gpVert.signed_point_id = IsCyclic(s)? -offsetInStroke: offsetInStroke;
    gpVert.packed_asp_hard_rot = pack_rotation_aspect_hardness_miter(0, 1.0f, 0.0f, 60.0f);
    gpVert.uv_fill = float2(i, 0); 
    gpVert.u_stroke = s.distFromTail;
    gpVert.opacity = 1.0f;
    
    
    _denseArray[globalOffset] = gpVert;
    
    GreasePencilColorVert gpColor;
    gpColor.fcol = float4(1.0f, 1.0f, 1.0f, 1.0f);
    gpColor.vcol = float4(1.0f, 1.0f, 1.0f, 1.0f);
    
    _colorArray[globalOffset] = gpColor;
    
    
    if (s.minPoint == i && IsCyclic(s))
    {   
        //link stoke start to the end. to get 4th point for the 1st edge
        _denseArray[tail.strokePointsOffset].stroke_id = tail.strokePointsOffset + tail.totalStrokeLength + 2;
        
        //add duplicate point at end, to render the last edge in the cycle
        //don't need to manually link because 4th point of the last edge is at index stroke_id+1
        uint globalOffsetEnd = tail.strokePointsOffset + tail.totalStrokeLength + 1;
        _denseArray[globalOffsetEnd] = gpVert;
        _colorArray[globalOffsetEnd] = gpColor;
    }
}