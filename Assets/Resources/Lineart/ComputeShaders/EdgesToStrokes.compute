#pragma kernel Initialize
#pragma kernel CalculateRanksAndDistances
#pragma kernel FindStrokeTail
#pragma kernel ResetNextPointer
#pragma kernel InitializeRanksAndDistances

#include "siloutte_defines.hh"

RWStructuredBuffer<StrokeData> _strokes; // read from silhouette pass (the same structured layout)

StructuredBuffer<int> _nextPointerSrc;
RWStructuredBuffer<int> _nextPointerDst; // per-stroke successor index (adjacency)

uint _NumFaces;

// Convert float to a lexicographically sortable uint representation (preserves ordering including negatives)
uint FloatToSortableUint(float f)
{
    uint u = asuint(f);
    // flip sign bit so that integer ordering matches float ordering
    return (u & 0x80000000u) ? ~u : (u ^ 0x80000000u);
}

// --------

[numthreads(64,1,1)]
void Initialize(uint3 id : SV_DispatchThreadID)
{
    uint i = id.x;
    if (i >= _NumFaces) return;
    StrokeData s = _strokes[i];
    _strokes[i].minPoint = i;
    _nextPointerDst[i] = s.adj;
}

[numthreads(64,1,1)]
void ResetNextPointer(uint3 id : SV_DispatchThreadID)
{
    uint i = id.x;
    if (i >= _NumFaces) return;
    StrokeData s = _strokes[i];
    _nextPointerDst[i] = s.adj;
}

bool lessThan(float3 a, float3 b)
{
    if (a.x != b.x) return a.x < b.x;
    if (a.y != b.y) return a.y < b.y;
    return a.z < b.z;
}

bool lessThan(StrokeData a, StrokeData b)
{
    if (a.adj != b.adj)
    {
        if (a.adj == ADJ_NONE)
            return true;
        if (b.adj == ADJ_NONE)
            return false;
    }
    return lessThan(a.pos, b.pos);
}


// Use pointer jumping to propagate the minimum point as the tail in all edges
[numthreads(64,1,1)]
void FindStrokeTail(uint3 id : SV_DispatchThreadID)
{
    uint i = id.x;
    if (i >= _NumFaces) return;
    StrokeData s = _strokes[i];
    
    if (IsInvalid(s))
    {
        _nextPointerDst[i] = INVALID_UINT;
        return;
    }

    int succ = _nextPointerSrc[i];
    _nextPointerDst[i] = succ;
    if (succ >= 0)
    {
        uint succMin = _strokes[_strokes[succ].minPoint].minPoint;
        if (lessThan(_strokes[succMin], _strokes[s.minPoint]))
        {
            _strokes[i].minPoint = succMin;
        }
        _nextPointerDst[i] = _nextPointerSrc[succ];
    }
}


[numthreads(64,1,1)]
void InitializeRanksAndDistances(uint3 id : SV_DispatchThreadID)
{
    uint i = id.x;
    if (i >= _NumFaces) return;
    StrokeData s = _strokes[i];
    if (IsInvalid(s))
    {
        _strokes[i].distFromTail = 0.0f;
        _strokes[i].rank = 0u;
        return;
    }

    bool isTail = (i == s.minPoint) || s.adj == ADJ_NONE;
    if (isTail)
    {
        _strokes[i].distFromTail = 0.0f;
        _strokes[i].rank = 0u;
        return;
    }
    else
    {
        float d = distance(s.pos, _strokes[s.adj].pos);
        _strokes[i].distFromTail = d;
        _strokes[i].rank = 1u;
        
        _strokes[s.adj].flags |= STROKE_FLAG_IS_CHILD;
    }
        
}

// Pointer-jumping list ranking: compute distance-to-tail (float) and hop count
[numthreads(64,1,1)]
void CalculateRanksAndDistances(uint3 id : SV_DispatchThreadID)
{
    uint i = id.x;
    if (i >= _NumFaces) return;
    StrokeData si = _strokes[i];
    if (IsInvalid(si))
    {
        _nextPointerDst[i] = INVALID_UINT;
        return;
    }

    if (i == si.minPoint)
    {
        if (si.adj != ADJ_NONE) _strokes[i].flags |= STROKE_FLAG_CYCLIC;
        _nextPointerDst[i] = _nextPointerSrc[i];
        return;
    }

    uint succ = _nextPointerSrc[i];
    _nextPointerDst[i] = succ;

    bool succIsTail = (succ == si.minPoint);

    StrokeData ss = _strokes[succ];
    _strokes[i].distFromTail += ss.distFromTail;
    _strokes[i].rank += ss.rank;

    if (succIsTail)
    {
        if (si.adj != ADJ_NONE) _strokes[i].flags |= STROKE_FLAG_CYCLIC;
    }
    else
    {
        _nextPointerDst[i] = _nextPointerSrc[succ];
    }
}