#pragma kernel InitPJ
#pragma kernel Reduce
#pragma kernel ListRankPJ
#pragma kernel FindMinPJ
#pragma kernel ResetNextPointer
#pragma kernel InitDistances

#include "siloutte_defines.hh"

RWStructuredBuffer<StrokeData> _strokes; // read from silhouette pass (the same structured layout)

StructuredBuffer<uint> _nextPointerSrc;
RWStructuredBuffer<uint> _nextPointerDst; // per-stroke successor index (adjacency)

uint _NumVerts;

// Convert float to a lexicographically sortable uint representation (preserves ordering including negatives)
uint FloatToSortableUint(float f)
{
    uint u = asuint(f);
    // flip sign bit so that integer ordering matches float ordering
    return (u & 0x80000000u) ? ~u : (u ^ 0x80000000u);
}

bool equals(float3 a, float3 b)
{
    return (a.x == b.x) && (a.y == b.y) && (a.z == b.z);
}

[numthreads(64,1,1)]
void InitPJ(uint3 id : SV_DispatchThreadID)
{
    uint i = id.x;
    if (i >= _NumVerts) return;
    StrokeData s = _strokes[i];
    _strokes[i].minPoint = i;
    uint succ = (s.adj >= 0) ? (uint)s.adj : INVALID_UINT;
    if (succ != INVALID_UINT)
    {
        StrokeData succStroke = _strokes[succ];
        if (!equals(succStroke.pos, s.pos))
        {
            _strokes[succ].flags|=STROKE_FLAG_IS_CHILD;
        }
    }
    
    _nextPointerDst[i] = succ;
}

[numthreads(64,1,1)]
void ResetNextPointer(uint3 id : SV_DispatchThreadID)
{
    uint i = id.x;
    if (i >= _NumVerts) return;
    StrokeData s = _strokes[i];
    _nextPointerDst[i] = (s.adj >= 0) ? (uint)s.adj : INVALID_UINT;
    _strokes[i].flags&=!STROKE_FLAG_IS_CHILD;
}


bool lessThan(float3 a, float3 b)
{
    if (a.x != b.x) return a.x < b.x;
    if (a.y != b.y) return a.y < b.y;
    return a.z < b.z;
}

bool lessThan(StrokeData a, StrokeData b)
{
    if (a.adj != b.adj)
    {
        if (a.adj == INVALID)
            return true;
        if (b.adj == INVALID)
            return false;
    }
    return lessThan(a.pos, b.pos);
}


// Pointer-jumping to propagate the minimum point
[numthreads(64,1,1)]
void Reduce(uint3 id : SV_DispatchThreadID)
{
    uint i = id.x;
    if (i >= _NumVerts) return;
    StrokeData s = _strokes[i];
    if (s.adj == INVALID)
    {
        _nextPointerDst[i] = INVALID_UINT;
        return;
    }

    uint succ = _nextPointerSrc[i];
    _nextPointerDst[i] = succ;
    if (succ != INVALID_UINT)
    {
        if (IsChild(_strokes[succ]) && equals(_strokes[succ].pos, s.pos))
        {
            return;
        }
        uint succ2hop = _nextPointerSrc[succ];
        if (succ2hop != INVALID_UINT)
        {
            if (!IsChild(_strokes[succ2hop]) && equals(_strokes[succ].pos, _strokes[succ2hop].pos))
            {
                _nextPointerDst[i] = succ2hop;
                //TODO: remove this
                _strokes[i].adj = succ2hop;
            }
        }
    }
}

// Pointer-jumping to propagate the minimum point
[numthreads(64,1,1)]
void FindMinPJ(uint3 id : SV_DispatchThreadID)
{
    uint i = id.x;
    if (i >= _NumVerts) return;
    StrokeData s = _strokes[i];
    if (s.adj == INVALID)
    {
        _nextPointerDst[i] = INVALID_UINT;
        return;
    }

    uint succ = _nextPointerSrc[i];
    _nextPointerDst[i] = succ;
    if (succ != INVALID_UINT)
    {
        uint succMin = _strokes[_strokes[succ].minPoint].minPoint;
        if (lessThan(_strokes[succMin], _strokes[s.minPoint]))
        {
            _strokes[i].minPoint = succMin;
        }
        _nextPointerDst[i] = _nextPointerSrc[succ];
    }
}


[numthreads(64,1,1)]
void InitDistances(uint3 id : SV_DispatchThreadID)
{
    uint i = id.x;
    if (i >= _NumVerts) return;
    StrokeData s = _strokes[i];
    if (s.adj == INVALID)
    {
        _strokes[i].distFromTail = 0.0f;
        _strokes[i].rank = 0u;
        return;
    }
    if (equals(s.pos, _strokes[s.adj].pos))
    {
        _strokes[i].adj = INVALID;
        _strokes[i].distFromTail = 0.0f;
        _strokes[i].rank = 0u;
        return;
    }

    bool isTail = (i == s.minPoint) || s.adj == ADJ_NONE;
    if (isTail)
    {
        _strokes[i].distFromTail = 0.0f;
        _strokes[i].rank = 0u;
    }
    else
    {
        float d = distance(s.pos, _strokes[s.adj].pos);
        _strokes[i].distFromTail = d;
        _strokes[i].rank = 1u;
        
        _strokes[s.adj].flags|=STROKE_FLAG_IS_CHILD;
    }
        
}

// Pointer-jumping list ranking: compute distance-to-tail (float) and hop count
[numthreads(64,1,1)]
void ListRankPJ(uint3 id : SV_DispatchThreadID)
{
    uint i = id.x;
    if (i >= _NumVerts) return;
    StrokeData si = _strokes[i];
    if (si.adj == INVALID)
    {
        _nextPointerDst[i] = INVALID_UINT;
        return;
    }

    if (i == si.minPoint)
    {
        if (si.adj != ADJ_NONE && si.adj != INVALID) 
            _strokes[i].flags|=STROKE_FLAG_CYCLIC;
        _nextPointerDst[i] = _nextPointerSrc[i];
        return;
    }

    uint succ = _nextPointerSrc[i];
    _nextPointerDst[i] = succ;

    bool succIsTail = (succ == si.minPoint);

    StrokeData ss = _strokes[succ];
    _strokes[i].distFromTail += ss.distFromTail;
    _strokes[i].rank += ss.rank;

    if (succIsTail)
    {
        if (ss.adj != ADJ_NONE && ss.adj != INVALID)
            _strokes[i].flags |= STROKE_FLAG_CYCLIC;
    }
    else
    {
        _nextPointerDst[i] = _nextPointerSrc[succ];
    }
}