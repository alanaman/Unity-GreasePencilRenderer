#pragma kernel InitPJ
#pragma kernel PointerJump
#pragma kernel FindMinPJ
// #pragma kernel AssignEndpoints

#define INVALID_UINT 0xFFFFFFFFu

struct StrokeData
{
    float3 pos[2];
    uint adj[2];
    uint valid;
    float3 faceNormal;
    uint minPoint[2];
};

RWStructuredBuffer<StrokeData> _strokes; // read from silhouette pass (the same structured layout)
// RWStructuredBuffer<StrokeData> _outStrokes; // we will write minLeftPoint/minRightPoint here

RWStructuredBuffer<uint> _next; // per-stroke connected-component label

uint _NumFaces; // set from C#

// Convert float to a lexicographically sortable uint representation (preserves ordering including negatives)
uint FloatToSortableUint(float f)
{
    uint u = asuint(f);
    // flip sign bit so that integer ordering matches float ordering
    return (u & 0x80000000u) ? ~u : (u ^ 0x80000000u);
}

// Kernel: initialize labels to self for valid strokes, INVALID otherwise
[numthreads(64,1,1)]
void InitPJ(uint3 id : SV_DispatchThreadID)
{
    uint i = id.x;
    if (i >= _NumFaces) return;
    StrokeData s = _strokes[i];
    _strokes[i].minPoint[0] = i;
    _strokes[i].minPoint[1] = i;
    if (s.valid == 1u)
    {
        _next[i] = s.adj[0];
    }
    else
    {
        _next[i] = INVALID_UINT;
    }
}

bool lessThan(float3 a, float3 b)
{
    if (a.x != b.x) return a.x < b.x;
    if (a.y != b.y) return a.y < b.y;
    return a.z < b.z;
}

[numthreads(64,1,1)]
void FindMinPJ(uint3 id : SV_DispatchThreadID)
{
    uint i = id.x;
    if (i >= _NumFaces) return;
    StrokeData s = _strokes[i];
    if (s.valid == 0u)
    {
        // already marked invalid in InitLabels
        return;
    }

    if (_next[i] == INVALID_UINT)
    {
        // no neighbors, nothing to do
        return;
    }

    uint next = _next[i];
    if (lessThan(_strokes[next].pos[0], s.pos[0]) || lessThan(_strokes[next].pos[1], s.pos[0]))
    {
        _strokes[i].minPoint[0] = _strokes[next].minPoint[0];
    }
    _next[i] = _next[_next[i]];
}

// Kernel: pointer jumping (Wyllie-like) to reduce labels quickly
// We perform an in-kernel iterative pointer-jumping loop; this converges in O(log N) steps
[numthreads(64,1,1)]
void PointerJump(uint3 id : SV_DispatchThreadID)
{
    uint i = id.x;
    if (i >= _NumFaces) return;
    uint lbl = _next[i];
    if (lbl == INVALID_UINT) return;

    // iterate a fixed number of pointer-jumping rounds (enough for typical mesh sizes)
    // 16 iterations support up to 2^16 hops
    [loop]
    for (int it = 0; it < 16; ++it)
    {
        uint next = _next[lbl];
        if (next == INVALID_UINT || next == lbl) break;
        // collapse: take the smaller label to prefer deterministic root
        uint newlbl = (next < lbl) ? next : lbl;
        // try to further hop
        uint next2 = _next[newlbl];
        if (next2 == INVALID_UINT || next2 == newlbl) { lbl = newlbl; break; }
        lbl = (next2 < newlbl) ? next2 : newlbl;
    }
    _next[i] = lbl;
}

// // Kernel: assign minLeftPoint/minRightPoint for each stroke based on per-component minima
// [numthreads(64,1,1)]
// void AssignEndpoints(uint3 id : SV_DispatchThreadID)
// {
//     uint i = id.x;
//     if (i >= _NumFaces) return;
//     StrokeData s = _strokes[i];
//     uint comp = _next[i];
//     if (comp == INVALID_UINT || s.valid == 0u)
//     {
//         // mark invalid
//         _outStrokes[i] = s;
//         _outStrokes[i].minPoint[0] = INVALID_UINT;
//         _outStrokes[i].minPoint[1] = INVALID_UINT;
//         return;
//     }
//
//     uint cmx = _compMinX[comp];
//     uint cmy = _compMinY[comp];
//     uint cmz = _compMinZ[comp];
//
//     // default to endpoint 0 as min
//     uint minIdx = 0u;
//     // check endpoint 0
//     uint ux0 = FloatToSortableUint(s.pos[0].x);
//     uint uy0 = FloatToSortableUint(s.pos[0].y);
//     uint uz0 = FloatToSortableUint(s.pos[0].z);
//     if (ux0 == cmx && uy0 == cmy && uz0 == cmz)
//     {
//         minIdx = 0u;
//     }
//     else
//     {
//         uint ux1 = FloatToSortableUint(s.pos[1].x);
//         uint uy1 = FloatToSortableUint(s.pos[1].y);
//         uint uz1 = FloatToSortableUint(s.pos[1].z);
//         if (ux1 == cmx && uy1 == cmy && uz1 == cmz)
//             minIdx = 1u;
//         else
//             minIdx = 0u; // no exact match (degenerate), fallback
//     }
//
//     s.minLeftPoint = minIdx; // 0 or 1
//     s.minRightPoint = (minIdx == 0u) ? 1u : 0u;
//
//     _outStrokes[i] = s;
// }
