#pragma kernel InitPJ
#pragma kernel ListRankPJ
#pragma kernel FindMinPJ
#pragma kernel ResetNextPointer
#pragma kernel InitDistances

#include "siloutte_defines.hh"

RWStructuredBuffer<StrokeData> _strokes; // read from silhouette pass (the same structured layout)


// TODO: use src and dest buffers to avoid race conditions
RWStructuredBuffer<uint> _nextPointer; // per-stroke successor index (adjacency)

uint _NumFaces;

// Convert float to a lexicographically sortable uint representation (preserves ordering including negatives)
uint FloatToSortableUint(float f)
{
    uint u = asuint(f);
    // flip sign bit so that integer ordering matches float ordering
    return (u & 0x80000000u) ? ~u : (u ^ 0x80000000u);
}

// --------

[numthreads(64,1,1)]
void InitPJ(uint3 id : SV_DispatchThreadID)
{
    uint i = id.x;
    if (i >= _NumFaces) return;
    StrokeData s = _strokes[i];
    _strokes[i].minPoint = i;

    // Initialize pointer for pointer-jumping passes
    _nextPointer[i] = (s.valid == 1u) ? s.adj : INVALID_UINT;
}

[numthreads(64,1,1)]
void ResetNextPointer(uint3 id : SV_DispatchThreadID)
{
    uint i = id.x;
    if (i >= _NumFaces) return;
    StrokeData s = _strokes[i];
    _nextPointer[i] = (s.valid == 1u) ? s.adj : INVALID_UINT;
}

bool lessThan(float3 a, float3 b)
{
    if (a.x != b.x) return a.x < b.x;
    if (a.y != b.y) return a.y < b.y;
    return a.z < b.z;
}

bool lessThan(StrokeData a, StrokeData b)
{
    if (a.adj != b.adj)
    {
        if (a.adj == INVALID_UINT)
            return true;
        if (b.adj == INVALID_UINT)
            return false;
    }
    return lessThan(a.pos, b.pos);
}

// Pointer-jumping to propagate the minimum point
[numthreads(64,1,1)]
void FindMinPJ(uint3 id : SV_DispatchThreadID)
{
    uint i = id.x;
    if (i >= _NumFaces) return;
    StrokeData s = _strokes[i];
    if (s.valid == 0u)
    {
        return;
    }

    uint succ = _nextPointer[i];
    if (succ != INVALID_UINT)
    {
        uint succMin = _strokes[ _strokes[succ].minPoint ].minPoint;
        if (lessThan(_strokes[succMin], _strokes[s.minPoint]))
        {
            _strokes[i].minPoint = succMin;
        }
        // jump to grand-successor
        _nextPointer[i] = _nextPointer[succ];
    }
}


[numthreads(64,1,1)]
void InitDistances(uint3 id : SV_DispatchThreadID)
{
    uint i = id.x;
    if (i >= _NumFaces) return;
    StrokeData s = _strokes[i];
    if (s.valid == 0u)
    {
        _strokes[i].distFromTail = 0.0f;
        _strokes[i].rank = 0u;
        return;
    }

    bool isTail = (i == s.minPoint) || s.adj == INVALID_UINT;
    if (isTail)
    {
        _strokes[i].distFromTail = 0.0f;
        _strokes[i].rank = 0u;
        return;
    }
    else
    {
        float d = distance(s.pos, _strokes[s.adj].pos);
        _strokes[i].distFromTail = d;
        _strokes[i].rank = 1u;
        
        //TODO: move this to somewhere intuitive
        _strokes[s.adj].isChild = 1;
    }
        
}

// Pointer-jumping list ranking: compute distance-to-tail (float) and hop count
[numthreads(64,1,1)]
void ListRankPJ(uint3 id : SV_DispatchThreadID)
{
    uint i = id.x;
    if (i >= _NumFaces) return;
    StrokeData si = _strokes[i];
    if (si.valid == 0u) return;

    // Stop at tail nodes (as defined by i == minPoint)
    if (i == si.minPoint)
    {
        return;
    }

    uint succ = _nextPointer[i];
    if (succ == INVALID_UINT) return;

    StrokeData ss = _strokes[succ];
    bool succIsTail = (succ == ss.minPoint);

    // accumulate distance and hop count from successor
    _strokes[i].distFromTail += ss.distFromTail;
    _strokes[i].rank += ss.rank;

    // If successor is a tail, stop jumping; otherwise jump to grand-successor
    if (succIsTail)
    {
        _nextPointer[i] = INVALID_UINT;
        // mark as not cyclic if tail does not loop
        _strokes[i].isCyclic = ss.adj != INVALID_UINT;
    }
    else
    {
        _nextPointer[i] = _nextPointer[succ];
    }
}