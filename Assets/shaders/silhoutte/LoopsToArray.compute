#pragma kernel SetStrokeLengthAtTail
#pragma kernel CalculateArrayOffsets
#pragma kernel MoveToDenseArray
#pragma kernel InvalidateEntries

#include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl"
#include "siloutte_defines.hh"
#include "../greasepencil/gpencil_info.hh"
#include "../greasepencil/gpencil_defines.hh"

RWStructuredBuffer<StrokeData> _strokes;
uint _NumFaces;

RWStructuredBuffer<uint> numStrokesCounter;
RWStructuredBuffer<uint> numStrokePointsCounter;


RWStructuredBuffer<GreasePencilStrokeVert> _denseArray;
RWStructuredBuffer<GreasePencilColorVert> _colorArray;

[numthreads(64,1,1)]
void SetStrokeLengthAtTail(uint3 id : SV_DispatchThreadID)
{
    uint idx = id.x;
    if (idx >= _NumFaces) return;
    StrokeData s = _strokes[idx];
    if (!s.isChild)
    {
        _strokes[s.minPoint].totalStrokeLength = s.rank +1;
    }
}

[numthreads(64,1,1)]
void CalculateArrayOffsets(uint3 id : SV_DispatchThreadID)
{
    uint i = id.x;
    if (i >= _NumFaces) return;
    StrokeData s = _strokes[i];
    if (s.valid == 0u) return;
    
    
    uint strokeBufferLength = _strokes[s.minPoint].totalStrokeLength + (s.isCyclic?1:0) + 2;
    
    if (_strokes[i].minPoint == i)
    {
        InterlockedAdd(numStrokePointsCounter[0], strokeBufferLength, _strokes[i].strokePointsOffset);
        InterlockedAdd(numStrokesCounter[0], 1u, _strokes[i].strokeIdx);
    }
}

[numthreads(64,1,1)]
void InvalidateEntries(uint3 id : SV_DispatchThreadID)
{
    uint i = id.x;
    _denseArray[i].mat = -1;
}
    

uint unit_float_to_uchar_clamp(float val)
{
    return (uint)round(saturate(val) * 255.0);
}

uint pack_rotation_aspect_hardness_miter(
    const float rot,
    const float asp,
    const float softness,
    const float miter_angle)
{
    uint packed = 0;
    /* Aspect uses 9 bits */
    float asp_normalized = (asp > 1.0f) ? (1.0f / asp) : asp;
    /* Use the default aspect ratio of 1 when the value is outside of the valid range. */
    if (asp_normalized <= 0.0f) {
        asp_normalized = 1.0f;
    }
    packed |= uint(unit_float_to_uchar_clamp(asp_normalized));
    /* Store if inverted in the 9th bit. */
    if (asp > 1.0f) {
        packed |= 1 << 8;
    }
    /* Rotation uses 9 bits */
    /* Rotation are in [-90..90] degree range, so we can encode the sign of the angle + the cosine
     * because the cosine will always be positive. */
    packed |= unit_float_to_uchar_clamp(cos(rot)) << 9;
    /* Store sine sign in 9th bit. */
    if (rot < 0.0f) {
        packed |= 1 << 17;
    }
    /* Hardness uses 8 bits */
    packed |= unit_float_to_uchar_clamp(1.0f - softness) << 18;
    

    /* Miter Angle uses the last 6 bits */
    if (miter_angle <= GP_STROKE_MITER_ANGLE_ROUND) {
        packed |= GP_CORNER_TYPE_ROUND_BITS << 26;
    }
    else if (miter_angle >= GP_STROKE_MITER_ANGLE_BEVEL) {
        packed |= GP_CORNER_TYPE_BEVEL_BITS << 26;
    }
    else {
        const float miter_norm = (miter_angle / PI);
        packed |= clamp(int(miter_norm * GP_CORNER_TYPE_MITER_NUMBER), 1, GP_CORNER_TYPE_MITER_NUMBER) << 26;
    }

    return packed;
}

float _radiusMultiplier = 1.0f;

[numthreads(64,1,1)]
void MoveToDenseArray(uint3 id : SV_DispatchThreadID)
{
    uint i = id.x;
    if (_strokes[i].valid == 0u) return;
    StrokeData s = _strokes[i];
    //TODO try and remove tail access here
    StrokeData tail = _strokes[s.minPoint]; 
    int offsetInStroke = s.rank+1;
    uint globalOffset = tail.strokePointsOffset + offsetInStroke;
    
    
    GreasePencilStrokeVert gpVert;
    gpVert.pos = s.pos;
    gpVert.radius = _radiusMultiplier;
    
    gpVert.mat = 0;
    gpVert.stroke_id = tail.strokePointsOffset;
    gpVert.signed_point_id = s.isCyclic? -offsetInStroke: offsetInStroke;
    gpVert.packed_asp_hard_rot = pack_rotation_aspect_hardness_miter(0, 1.0f, 0.0f, 60.0f);
    // this is only used for fill, we only create an outline.
    gpVert.uv_fill = float2(0.0f, 0.0f); 
    gpVert.u_stroke = s.distFromTail;
    gpVert.opacity = 1.0f;
    
    
    _denseArray[globalOffset] = gpVert;
    
    _colorArray[globalOffset].fcol = float4(1.0f, 1.0f, 1.0f, 1.0f);
    _colorArray[globalOffset].vcol = float4(1.0f, 1.0f, 1.0f, 1.0f);
    
    
    //cyclic strokes require an extra point at the end
    // this will be added by the tail
    if (s.minPoint == i && s.isCyclic)
    {   
        _denseArray[tail.strokePointsOffset].stroke_id = tail.strokePointsOffset + tail.totalStrokeLength + (s.isCyclic?1:0) + 1;
    
        gpVert.stroke_id = tail.strokePointsOffset;
        _denseArray[tail.strokePointsOffset + tail.totalStrokeLength + 1] = gpVert;
    }
}