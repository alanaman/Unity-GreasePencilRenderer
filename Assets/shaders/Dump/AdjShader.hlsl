// MIT License

// Copyright (c) 2020 NedMakesGames

// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files(the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and / or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions :

// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.

// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

// Make sure this file is not included twice
#ifndef PYRAMIDFACES_INCLUDED
#define PYRAMIDFACES_INCLUDED

// Include helper functions from URP
#include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/Lighting.hlsl"
#include "NMGGeometryHelpers.hlsl"

// This structure is created by the renderer and passed to the Vertex function
// It holds data stored on the model, per vertex
struct Attributes {
    float4 positionOS   : POSITION; // Position in object space
    float2 uv           : TEXCOORD0; // UVs
};
// Other common semantics include NORMAL, TANGENT, COLOR

// This structure is generated by the vertex function and passed to the geometry function
struct VertexOutput {
    float3 positionWS   : TEXCOORD0; // Position in world space
    float2 uv           : TEXCOORD1; // UVs
};

// This structure is generated by the geometry function and passed to the fragment function
// Remember the renderer averages these values between the three points on the triangle 
struct GeometryOutput {
    float3 positionWS               : TEXCOORD0; // Position in world space
    float3 normalWS                 : TEXCOORD1; // Normal vector in world space
    float2 uv                       : TEXCOORD2; // UVs

    float4 positionCS               : SV_POSITION; // Position in clip space
};


TEXTURE2D(_BaseMap); SAMPLER(sampler_BaseMap); float4 _BaseMap_ST;
float4 _BaseColor;            // property _BaseColor("Base Color", Color) defined in Properties
float _PyramidHeight;

// Vertex functions

VertexOutput Vertex(Attributes input) {
    // Initialize an output struct
    VertexOutput output = (VertexOutput)0;

    // Use this URP functions to convert position to world space
    // The analogous function for normals is GetVertexNormalInputs
    VertexPositionInputs vertexInput = GetVertexPositionInputs(input.positionOS.xyz);
    output.positionWS = vertexInput.positionWS;

    // TRANSFORM_TEX is a macro which scales and offsets the UVs based on the _MainTex_ST variable
    output.uv = TRANSFORM_TEX(input.uv, _BaseMap);
    return output;
}

// Geometry functions

GeometryOutput SetupVertex(float3 positionWS, float3 normalWS, float2 uv) {
    // Setup an output struct
    GeometryOutput output = (GeometryOutput)0;
    output.positionWS = positionWS;
    output.normalWS = normalWS;
    output.uv = uv;
    // This function calculates clip space position, taking the shadow caster pass into account
    output.positionCS = CalculatePositionCSWithShadowCasterLogic(positionWS, normalWS);
    return output;
}

void SetupAndOutputTriangle(inout TriangleStream<GeometryOutput> outputStream, VertexOutput a, VertexOutput b, VertexOutput c) {
    // Restart the triangle strip, signaling the next appends are disconnected from the last
    outputStream.RestartStrip();
    // Since we extrude the center face, the normal must be recalculated
    float3 normalWS = GetNormalFromTriangle(a.positionWS, b.positionWS, c.positionWS);
    // Add the output data to the output stream, creating a triangle
    outputStream.Append(SetupVertex(a.positionWS, normalWS, a.uv));
    outputStream.Append(SetupVertex(b.positionWS, normalWS, b.uv));
    outputStream.Append(SetupVertex(c.positionWS, normalWS, c.uv));
}

// We create three triangles from one, so there will be 9 vertices
[maxvertexcount(3)]
void Geometry(triangleadj VertexOutput inputs[6], inout TriangleStream<GeometryOutput> outputStream) {
    // // Create a fake VertexOutput for the center vertex
    // VertexOutput center = (VertexOutput)0;
    // // We need the triangle's normal to extrude the center point
    // float3 triNormal = GetNormalFromTriangle(inputs[0].positionWS, inputs[2].positionWS, inputs[4].positionWS);
    // // Find the center position and extrude by _PyramidHeight along the normal
    // center.positionWS = GetTriangleCenter(inputs[0].positionWS, inputs[2].positionWS, inputs[4].positionWS) + triNormal * _PyramidHeight;
    // // Average the UVs as well
    // center.uv = GetTriangleCenter(inputs[0].uv, inputs[2].uv, inputs[4].uv);

    // Create the three triangles.
    // Triangles must wind clockwise or they will not render by default
    SetupAndOutputTriangle(outputStream, inputs[0], inputs[1], inputs[2]);
    // SetupAndOutputTriangle(outputStream, inputs[2], inputs[4], center);
    // SetupAndOutputTriangle(outputStream, inputs[4], inputs[0], center);
}

// Fragment functions

float4 Fragment(GeometryOutput input) : SV_Target
{
#ifdef SHADOW_CASTER_PASS
    return float4(0,0,0,1);
#else
    // -------------------------------
    // Prepare InputData (as URP expects)
    // -------------------------------
    InputData lightingInput = (InputData)0;

    // Core values URP needs
    lightingInput.positionWS             = input.positionWS;
    lightingInput.normalWS               = normalize(input.normalWS);           // normalize!!!
    lightingInput.viewDirectionWS        = GetViewDirectionFromPosition(input.positionWS);

    // shadowCoord: derived from positionCS (you already computed this in SetupVertex)
    // CalculateShadowCoord is present in your file earlier â€” reuse it
    lightingInput.shadowCoord            = CalculateShadowCoord(input.positionWS, input.positionCS);

    // baked GI: if you do not have baked probes, set a safe default (1 = neutral)
    lightingInput.bakedGI                = float3(1.0, 1.0, 1.0);

    // vertex lighting: usually 0 unless you computed it; set 0 for safety
    lightingInput.vertexLighting         = 0;

    // normalized screen-space UV used by some GI/fog code; provide something valid
    // If you have a helper for normalized screen uv, use it. Otherwise zero is safe.
    lightingInput.normalizedScreenSpaceUV = float2(0.0, 0.0);

    // fogCoord: URP expects a fog coordinate. Provide a value in the same space URP expects.
    // Many URP shaders put view-space z into fogCoord. We can compute a conservative value:
    // If you have ComputeFogFactorZ0ToFar or ComputeFogFactor helper, use that; else set 0.
    #if defined(_FOG_FRAGMENT)
        lightingInput.fogCoord = -mul(UNITY_MATRIX_V, float4(input.positionWS,1)).z;
    #else
        lightingInput.fogCoord = 0;
    #endif

    // -------------------------------
    // Prepare SurfaceData (fully initialized)
    // -------------------------------
    SurfaceData surfaceData = (SurfaceData)0;
    float3 tex = SAMPLE_TEXTURE2D(_BaseMap, sampler_BaseMap, input.uv).rgb;
    surfaceData.albedo      = tex * _BaseColor.rgb;
    surfaceData.alpha       = _BaseColor.a;
    surfaceData.specular    = 0.5;    // keep reasonable defaults
    surfaceData.smoothness  = 0.5;
    surfaceData.metallic    = 0.0;
    surfaceData.emission    = float3(0.0,0.0,0.0);
    surfaceData.occlusion   = 1.0;
    surfaceData.normalTS    = float3(0,0,1);
    surfaceData.clearCoatMask = 0;
    surfaceData.clearCoatSmoothness = 1;
    
    float4 lit = UniversalFragmentBlinnPhong(lightingInput, surfaceData);

    return lit;
#endif
}


#endif